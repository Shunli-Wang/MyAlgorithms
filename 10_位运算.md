&emsp;&emsp;位运算题目一般带有一些神仙题的特质，见过就会，没见过就不会。产生这种误区还是因为对位运算最基本的技巧掌握不熟。

# 1.位运算基础
- **整型数字范围**：32位整型数字表示范围为：-2^31 --> 2^31-1，约为-21亿到+21亿，共有约42亿个数。负数在计算机中表示为补码，补码是原码保留符号位取反之后再加1。
```java
 0:             00000000|00000000|00000000|00000000
 1:             00000000|00000000|00000000|00000001 // 整数补码是自身
-1:             11111111|11111111|11111111|11111111 // 补码
 2147483647:    01111111|11111111|11111111|11111111
-2147483648:    10000000|00000000|00000000|00000000 // 最小数的补码，在32位下没有原码
// 最左侧的一位能够区分“1-负数”和“0-非负数”，本质上是认为0是正数。
```
- **取最右侧1**：数字取反加1后，再与自身相与，得到最右侧1的位置。（取反加1与自身）
```java
a:          00001100
~a+1:       11110011 + 1 = 11110100
(~a+1)&a:   00000100
```

# 题53.无比较判断大小
- **题目**：给定两个有符号32位整数a和b，返回较大数，不能使用任何比较判断。
- **分析**：两数字同号时可以使用做差正负分析判断大小；两数字异号时有溢出风险，只使用符号判断即可。
```java

public static int flip(int n){
    return n ^ 1;
}

public static int flag(int n){
    // n为负数: 返回0
    // n为非负数: 返回1
    return flip((n >> 31) & 1); // 右移31位再与1，可以获取符号位
}

public static int max(int a, int b){
    int c = a - b;
    int flgA = flag(a);
    int flgB = flag(b);
    int flgC = flag(c);
    int difFlg = flgA ^ flgB; // 异号得1,需要比较正负
    int sameFlg = flip(difFlg); // 同号得1,判断C正负; 
    int isA = difFlg * flgA + sameFlg * flgC; // 汇聚所有选A的情况, 互斥变量求和代替if-else结构
    int isB = flip(isA);
    return isA * a + isB * B;
}
```

# 题54.判断2和4的幂
- **题目**：判断一个32位的正数是不是2的幂、4的幂。
```java
2^0: 00000001
2^1: 00000010
2^2: 00000100
2^3: 00001000
...
// ----------
4^0: 00000001
4^1: 00000100
4^2: 00010000
4^3: 01000000
...
```

- **2次幂判断方法1**：2的整数次幂在全位上只有一个位置是1，因此通过取最右侧1的操作之后，和原数对比，若相等则是；不等则不是。
```java
public static boolean is2Power(int n){
    return (~n + 1) & n == n;
}
```

- **2次幂判断方法2**：若是2的整数次幂，则减1操作会将所有1后面的0打散，此时再与原数相与，最终得0说明原数符合要求。
```java
public static boolean is2Power(int n){
    return (n & (n - 1)) == 0;
}
```

- **4次幂判断方法**：首先判断是不是2的整数次幂，若是再判断唯一的1是否在偶数位置，即和01010101|01010101|01010101|01010101相与结果不为0，则为4的整数次幂。
```java
public static boolean is4Power(int n){
    return (n & (n - 1)) == 0 && (n & 0x55555555) != 0 ;
}
```









# 题55.位运算加减乘除
- **题目**：给定两个有符号32位整数a和b，不能使用算数运算符，分别实现a和b的加减乘除运算。无需保证计算过程中不发生溢出。
- **加法实现**：将a和b两数的加法拆解为以下两个过程：
    - **无进位相加（异或）**：将两个数通过异或运算得到无进位相加结果；
    - **进位确定（与结果左移）**：将两个数字相与，结果左移一位得到进位信息。此时两数相加等价为此两值相加。
    - **循环计算**：不断计算无进位相加和进位结果，直到某一步没有进位信息，即时最终结果。
```java
  13:   01101 +
   7:   00111
---------------
   ^:   01010 +
&<<1:   01010
---------------
   ^:   00000 + 
&<<1:   10100
---------------
   ^:   10100
&<<1:   00000
---------------
 ans:   10100 = 20

// 无法处理溢出情况
public static int add(int a, int b){
    int sum = a;
    while(b != 0){
        a = a ^ b; // 进行无进位相加
        b = (a & b) << 1; // 计算进位信息
        sum = a; // 无进位信息传递
    }
    return sum;
}
```

- **减法实现**：可以用加法进行拼凑。在补码表示中，一个数字全部取反再加1就是相反数。
```java
public static int negNum(int n){
    return add(~n, 1); // 补码下的计算方法
}

public static int minus(int a, int b){
    return add(a, negNum(b));
}
```

- **乘法实现**：借鉴小学的计算方法，通过不断地考察b最右侧的1来完成a的左移和累加，得到最终结果。
```java
        a:  011010| *
        b:  010110|
    ------------------
            000000|  << 0 // 01011[0]
           011010 |  << 1 // 0101[1]0
          011010  |  << 2 // 010[1]10
         000000   |  << 3 // 01[0]110
        011010    |  << 4 // 0[1]0110
       000000     |  << 5 // [0]10110
    ------------------

public static int multi(int a, int b){
    int res = 0;
    while(b != 0){
        if(b & 1 == 1){ // b最右侧的1有值，进行累加
            res = add(res, a);
        }
        a << 1; // 完成一层计算之后a左移
        b >>> 1; // 完成一层计算之后b无符号右移，继续判断最右侧的1
    }
    return res;
}
```

- **除法实现**：

```java
// 考虑乘法过程: 00101 * 01100 = 00111100
        00101| *
        01100|
    ------------
      0010100| +
     00101000|
    ------------
     00111100|

// 逆运算除法过程: 00111100 / 00101 = 01100

```









