&emsp;&emsp;这些东西是被火车撞了都不能忘的。

# 1.并查集(Union Find)
- **基本概念**：能够支持快速集合合并的基础数据结构，本质上是一个`往上指向`的图结构，伴随索引优化过程。有很多种实现方式可以完成这两个功能，但是想要快速实现此两功能（即O(1)时间复杂度）还是需要靠并查集。如果使用链表实现并查集，则union快但是isSameSet慢；如果使用哈希表实现并查集，则isSameSet快但是union慢。
- **基本功能**：在用户预先给定所有元素的情况下，对外提供两个接口：
    - **bool isSameSet(a, b)**：查询两个元素是否在一个集合内；
    - **void union(a, b)**：将a和b所在的两个集合进行合并。

- **构建过程**：
    - **元素初始化**：对用户给定的所有元素进行二次包装，内部添加指针指向自己；
    - **isSameSet(a, b)**：对两个元素分别进行向上索引一直到最顶端（往上不能再往上），如果为同一元素则说明在同一集合内；
    - **union(a, b)**：先调用isSameSet判断是否在一个集合，若在同集合则不操作；若不在同集合则将短链顶端元素指针指向到长链顶端元素；
    - **findHead(a)扁平优化**：调用isSameSet时存在一个持续向上搜索过程，此过程中蕴含着一个重要优化。因为是以链表的形式索引到顶端元素Top，索引中将所有沿途节点入栈，到达Top元素之后修改所有栈内元素指针统一指向Top，实现集合内元素的扁平化。此优化解决了链过长的问题，只需处理一次即可完成高效查询。
<div align=center>
<img src="./img/09_img/unionFind.png" width="380px"/>
</div>

- **基于哈希表的实现**：通过哈希表实现元素和父元素的对应，也可以使用链表方法实现。
    - **elementMap(V, E)**：每个值到元素的映射；
    - **fatherMap(E, E)**：每个元素到父元素的映射；
    - **sizeMap(E, int)**：只有顶端元素才有集合元素数量记录。

- **复杂度分析**：并查集结构在1964年被发明，其复杂度在1969年才被证明。设元素数量为N，当调用次数达到O(N)级别和O(N)以上时，单次的平均代价为O(1)。当findHead(a)函数调用次数远远小于N时无法保证O(1)。实际上并不是O(1)，而是O(a(N))，阿尔法函数是一个增长速度极其缓慢的函数（当N为宇宙原子数量10^80次方时a(N)<6），因此日常情况下可以认为复杂度为O(1)。

```java
public static class Element<T> {
    public T value;
    
    public Element(T value) {
        this.value = value;
    }
}

public static class UnionFind<T> {
    public HashMap<T, Element<T>> elementMap; // 值到元素的映射
    public HashMap<Element<T>, Element<T>> fatherMap; // 元素到父节点的映射
    public HashMap<Element<T>, Integer> sizeMap; // 顶端元素的集合数量

    public UnionFind(List<T> dataList) { // 初始化，需要用户给定所有元素
        elementMap = new HashMap<>();
        fatherMap = new HashMap<>();
        sizeMap = new HashMap<>();
        for (T i : dataList) { // 所有元素自成集合
            Element<T> ele = new Element<T>(i);
            elementMap.put(i, ele);
            fatherMap.put(ele, ele);
            sizeMap.put(ele, 1);
        }
    }

    public Element<T> findHead(Element<T> ele) { // 带有扁平化优化的找头节点
        Stack<Element<T>> path = new Stack<>();
        while (ele != fatherMap.get(ele)) {
            path.push(ele); // 沿途节点入栈，待找到顶部节点之后依次修改链接。
            ele = fatherMap.get(ele);
        }
        while (!path.isEmpty()) { // 统一修改链接，扁平化
            fatherMap.put(path.pop(), ele);
        }
        return ele; // 返回顶部元素
    }

    public boolean isSameSet(T a, T b) {
        if (elementMap.containsKey(a) && elementMap.containsKey(b)) { // 不存在就不用找头了
            return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
        }
        return false;
    }

    public void unionSet(T a, T b) {
        if (elementMap.containsKey(a) && elementMap.containsKey(b)) { // 不存在就不用合并了
            if (!isSameSet(a, b)) { // 不在同一个集合才进行合并操作
                Element<T> aF = findHead(elementMap.get(a)); // 找到各自的头部节点
                Element<T> bF = findHead(elementMap.get(b));
                Element<T> bigSet = sizeMap.get(aF) > sizeMap.get(bF) ? aF : bF; // 重定向两个元素
                Element<T> smlSet = bigSet == aF ? bF : aF;
                fatherMap.put(smlSet, bigSet); // 小集合顶部挂载到大集合顶部
                sizeMap.put(bigSet, sizeMap.get(aF) + sizeMap.get(bF)); // 更新大集合的元素数量
                sizeMap.remove(smlSet); // 删除小集合的元素数量记录
            }
        }
    }
}
```


# 2.窗口内Max&Min更新


# 3.单调栈


# 题目.岛问题
- **题目**：一个矩阵只有0和1两种值，每个位置都可以和自己的上下左右四个位置相连，如果有一片1连在一起则被称为一个岛，求一个矩阵中有多少个岛？
```java
001010
111010
100100
000000
// 共有3个岛
```
- **分析**：每个元素逐个分析，使用infect感染过程将每个1片区更改为2片区。外部是两层for循环遍历，内部是infect函数递归更改值。
- **时间复杂度分析**：以每一个元素为中心，其上下左右分别只调用一次，除去第1次修改之外所有情况均是碰到就直接返回。因此复杂度为O(N*M)矩阵规模。

```java
public static void process(int[][] mat, int i, int j) {
    if (i < 0 || i == mat.length || j < 0 || j == mat[0].length || mat[i][j] != 1) {
        // 所有越界情况和0/2情况都直接返回，筛选1情况
        return;
    }
    mat[i][j] = 2;
    process(mat, i - 1, j);
    process(mat, i + 1, j);
    process(mat, i, j - 1);
    process(mat, i, j + 1);
}

public static int island(int[][] mat) {
    int cnt = 0;
    for (int i = 0; i < mat.length; i++) {
        for (int j = 0; j < mat[0].length; j++) {
            if (mat[i][j] == 1) { // 若此位置是1，则岛数量加一，执行感染过程
                cnt++;
                process(mat, i, j); // 以此点为起点开始感染过程
            }
        }
    }
    return cnt;
}

public static void main(String[] args) {
    int[][] mat = { { 1, 0 }, { 0, 1 } };
    System.out.println(island(mat));
}
```

# 题目.岛问题并行处理(Google级别面试题)
- **题目**：当岛问题的规模非常巨大时，例如对一个高清世界地图进行岛计算，设计一个并行算法解决岛问题。
- **类型分析**：在ACM和面试过程中绝大部分题目是单CPU单内存系统问题，面试阶段有可能碰到并行设计题目。此时不需要代码实现，只需要说清楚思路就可以了。考这样的题目也肯定是google级别的公司了。
- **解题思路**：考虑两个CPU的场景，将矩阵左右分为均等的两块。
<div align=center>
<img src="./img/09_img/islandPall.png" width="620px"/>
</div>

# 题目.单调栈使用

